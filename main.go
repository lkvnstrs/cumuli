// Cumuli - A followings visualizer for SoundCloud

// To do:
//  - Eliminate link duplicates
//  - Handle invalid users

package main 

import (
    "encoding/json"
    "io/ioutil"
    "log"
    "math"
    "net/http"
    "os"
    "strconv"
    "strings"
    "sync"
)

const NUM_RESULTS = 50

// A type for the final JSON result.
type Result struct {
    Nodes []Node `json:"nodes"`
    Links []Link `json:"links"`
}

// A type for each node.
type Node struct {
    Name string `json:"name"`
    Group int `json:"group"`
}

// A type for each link.
type Link struct {
    Source int `json:"source"`
    Target int `json:"target"`
}

// A type for a user's followings
type Followings struct {
    Whoms []string
    Who string
}

// Types for soundcloud unmarshaling
type scUser struct { FollowingCount float64  `json:"followings_count"` }
type scFollowing struct { Permalink string `json:"permalink"`}

func main() {
    // Handle home
    http.HandleFunc("/", MainHandler)

    log.Println("Running on port :8080")
    http.ListenAndServe(":8080", nil)
}

func MainHandler(rw http.ResponseWriter, r *http.Request) {

    // Get the query parameter for u
    uParam := r.FormValue("u")

    if uParam == "" {
        rw.Write([]byte("Gotta handle this"))
        return
    }

    // Split fParam into individual users
    users := strings.Split(uParam, " ")

    result := GetSharedFollowings(&users)

    out, err := json.Marshal(*result)
    if err != nil {
        log.Fatal(err)
    }

    rw.Write(out)
}

func GetAllFollowings(users []string) (<-chan Followings) {

    // Create a channel for the followings
    cf := make(chan Followings)
    
    // Iterate over the users and pass their
    // followings onto channel
    go func() {
        var wg sync.WaitGroup

        // GetFollowings for each user
        for _, u := range users {

            wg.Add(1)
            go func(u string) {
                cf <- Followings{Whoms: GetFollowings(u), Who:u}
                wg.Done()
            } (u)
        }

        wg.Wait()
        close(cf)
    } ()

    return cf

}

func GetFollowings(user string) ([]string) {

    var url string

    // Get the Soundcloud API client id
    clientId := os.Getenv("SC_CLIENT_ID")
    if clientId == "" {
        panic("darn")
    }

    // Get u's number of followings
    url = `http://api.soundcloud.com/users/` + user + `.json?client_id=` + clientId
    r, err := http.Get(url)
    if err != nil {
        panic(err)
    }
    defer r.Body.Close()

    body, err := ioutil.ReadAll(r.Body)
    if err != nil {
        panic(err)
    }

    // user object to store unmarshalled json
    var u scUser
    if err = json.Unmarshal(body, &u); err != nil {
        panic(err)
    }

    jsonFollowings := make([]scFollowing, NUM_RESULTS)
    followings := make([]string, int(u.FollowingCount))

    // Search for the user's followings
    // Iterate to account for the results limit
    countTo := math.Ceil(u.FollowingCount / float64(NUM_RESULTS))
    for i := 0; i < int(countTo); i++ {

        url = `http://api.soundcloud.com/users/` + user + `/followings.json?client_id=` + clientId + `&offset=` + strconv.Itoa(i * 50)
        r, err = http.Get(url)
        if err != nil {
            panic(err)
        }
        defer r.Body.Close()

        body, err = ioutil.ReadAll(r.Body)
        if err != nil {
            panic(err)
        }

        // unmarshal into jsonFollowings
        if err = json.Unmarshal(body, &jsonFollowings); err != nil {
            panic(err)
        }

        for j, jf := range jsonFollowings {
            index := j + (i * NUM_RESULTS)
            if index >= int(u.FollowingCount) {
                break
            }
            followings[index] = jf.Permalink   
        }
    }
    
    return followings
}

func GetSharedFollowings(users *[]string) (*Result) {
    
    // Get a channel of Followings for the given users
    cf := GetAllFollowings(*users)

    // Create two sets to handle consolidation of the map
    checkSet := make(map[string]bool)
    resultSet := make(map[string]bool)

    // Create a slice of Followings to check once the resultSet
    // is filled
    followings := make([]Followings, len(*users))

    // Create two slices to hold the nodes and links
    nodes := make([]Node, len(*users))
    links := []Link{}

    // Keep track of node numbers, which 
    // are generated by order
    nodeNums := make(map[string]int)
    nodeCount := 0

    for i, u := range *users {

        // Put each user in the check and results sets
        checkSet[u] = true
        resultSet[u] = true

        // Make a node from each user and 
        // pass it to the channel
        nodes[i] = Node{Name: u, Group: 1} // Group: 1 -> given user
        nodeNums[u] = nodeCount
        nodeCount++
    }

    // Grab the first collection of followings
    followings[0] = <-cf

    // Store first's followings in the set
    for _, f := range followings[0].Whoms {
        checkSet[f] = true
    }

    // Suck the remaining Followings into a hashmap
    fIndex := 1
    for fs := range cf {

        followings[fIndex] = fs

        for _, f := range fs.Whoms {
            if checkSet[f] {
                if !resultSet[f] {
                    // Append a new node onto the slice
                    nodes = append(nodes, Node{Name: f, Group: 2}) // Group: 2 -> following
                    nodeNums[f] = nodeCount
                    nodeCount++
                }
                resultSet[f] = true
            }
            checkSet[f] = true
        }

        fIndex++
    }

    // Iterate through followings checking the map
    for _, fs := range followings {
        for _, f := range fs.Whoms {
            if resultSet[f] {
                // Append a new link to the slice
                links = append(links, Link{Source: nodeNums[fs.Who], Target: nodeNums[f]})
            }
        }
    }

    // Return a pointer to a Result object
    return &Result{Nodes: nodes, Links: links}

}